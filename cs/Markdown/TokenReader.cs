using System;
using System.Collections.Generic;
using System.Text;

namespace Markdown
{
    public static class TokenReader
    {
        public static IEnumerable<Token> ReadTokens(string text)
        {
            throw new NotImplementedException();
            /*
             * Итак. Постараюсь свести свои мысли в одно сообщение.
             * 1. Думаю, здесь будет уместна идея со стаком по типу задач со скобками.
             * Но! Нам надо запоминать похоже не только какой символ был, но и позицию(для создания в последующем токена).
             * Идея сделать какой-то еще один класс, где будет хранится тип тэга и где он встретился. С ссылками(
             * которые я хотел бы добавить в будущем) еще надо подумать как сделать.
             * 2. Как говорилось выше, предлагаю сначала находить все токены, а потом уже обрабатывать их, т.е применять правила по сути
             * (по сложности вроде должно получится O(n+m^2), где m - кол-во токенов, а n - кол-во символов в тексте).
             * 3. Если мы будем обрабатывать токены, то нам по сути не понадобиться лист, в котором есть вложенные токены.
             * 4. Насчёт применившегося экранирования - можно попробовать так: конец токена перед ним, начало токена после него
             * 
            */
        }
    }
}
